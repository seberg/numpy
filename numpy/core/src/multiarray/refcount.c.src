/*
 * This module corresponds to the `Special functions for NPY_OBJECT`
 * section in the numpy reference for C-API.
 */

#define PY_SSIZE_T_CLEAN
#include <Python.h>
#include "structmember.h"

#define NPY_NO_DEPRECATED_API NPY_API_VERSION
#define _MULTIARRAYMODULE
#include "numpy/arrayobject.h"
#include "numpy/arrayscalars.h"

#include "npy_config.h"

#include "npy_pycompat.h"


/* Fill the data item with None before XDECREF, used to clear the array */
#define FILL_WITH_NONE(temp) do {        \
    PyObject *none = Py_None;            \
    NPY_COPY_PYOBJECT_PTR(data, &none);  \
    Py_INCREF(none);                     \
    Py_XDECREF(temp);                    \
    } while (0)


/**begin repeat
 * #name = INCREF, XDECREF, CLEAR, VISIT#
 * #inner_function = _PyArray_Item_INCREF, _PyArray_Item_XDECREF,
 *                   _PyArray_Item_CLEAR, _PyArray_Item_VISIT#
 * #is_visit_func = 0, 0, 0, 1#
 * #item_func = Py_XINCREF, Py_XDECREF,, Py_VISIT#
 * #set_to_none = 0, 0, 1, 0#
 * #silence_errors = 0, 0, 1, 1#
 * #context = "", "", "<ndarray.tp_clear>", "<ndarray.tp_traverse>"#
 */

/* Use macros to achieve the different behaviour and function signatures */
#if !@set_to_none@
   #define HANDLE_ITEM_AT(data) @item_func@(*data)
#else
    #define HANDLE_ITEM_AT(data) Py_XSETREF(*data, Py_None)
#endif


#define HANDLE_ITEM_AT_UNALIGNED(data)          \
    do {                                        \
        PyObject **_tmp;                        \
        NPY_COPY_PYOBJECT_PTR(_tmp, data);      \
        HANDLE_ITEM_AT(_tmp);                   \
        if (@set_to_none@) {                    \
            NPY_COPY_PYOBJECT_PTR(data, _tmp);  \
        }                                       \
    } while (0)


#if @is_visit_func@
    #define CALL_INNER_FUNCTION(data, descr) \
        @inner_function@(data, descr, visit, arg)
    // #define ERR_RETURN PyErr_WriteUnraisable(Py_None); return 0
#else
    #define CALL_INNER_FUNCTION(data, descr) @inner_function@(data, descr)
    // #define ERR_RETURN return -1;
#endif

#if @silence_errors@
    #define ERROR_RETURN                                            \
        do {                                                        \
            PyObject *_err_string = PyUString_FromString(@context@);\
            if (_err_string) {                                      \
                PyErr_WriteUnraisable(_err_string);                 \
                Py_DECREF(_err_string);                             \
            }                                                       \
            else {                                                  \
                PyErr_WriteUnraisable(Py_None);                     \
            }                                                       \
            /* Only Py_VISIT returns not 0 for the VISIT func */    \
            return 0;                                               \
        } while (0)
#else
    #define ERROR_RETURN return -1
#endif

/*
 * Function visiting all elements of object type within a given datatype.
 * This is for structured dtypes and the inner function may be called
 * recursively to visit all sub structures.
 * If this is the VISIT function, it needs special arguments for Python
 */
NPY_NO_EXPORT int 
 #if @is_visit_func@
    @inner_function@(char *data, PyArray_Descr *descr,
                     visitproc visit, void *arg)
#else
    @inner_function@(char *data, PyArray_Descr *descr)
#endif
{
    int retval = 0;

    if (!PyDataType_REFCHK(descr)) {
        return 0;
    }
    if (descr->type_num == NPY_OBJECT) {
        HANDLE_ITEM_AT_UNALIGNED(data);
    }
    else if (PyDataType_HASFIELDS(descr)) {
        PyObject *key, *value, *title = NULL;
        PyArray_Descr *new;
        int offset;
        Py_ssize_t pos = 0;

        while (!retval &&
                    PyDict_Next(descr->fields, &pos, &key, &value)) {
            if NPY_TITLE_KEY(key, value) {
                continue;
            }
            if (!PyArg_ParseTuple(value, "Oi|O", &new, &offset,
                                  &title)) {
                ERROR_RETURN;
            }
            retval = CALL_INNER_FUNCTION(data + offset, new);
        }
    }
    else if (PyDataType_HASSUBARRAY(descr)) {
        int size, i, inner_elsize;

        inner_elsize = descr->subarray->base->elsize;
        if (inner_elsize == 0) {
            /* There cannot be any elements, so return */
            return 0;
        }
        /* Subarrays are always contiguous in memory */
        size = descr->elsize / inner_elsize;

        for (i = 0; i < size; i++){
            /* Recursively increment the reference count of subarray elements */
            retval = CALL_INNER_FUNCTION(data + i * inner_elsize,
                                         descr->subarray->base);
        }
    }
    else {
        /* This path should not be reachable. */
        assert(0);
    }
    return retval;
}


NPY_NO_EXPORT int
#if @is_visit_func@
    _PyArray_@name@(PyArrayObject *mp, visitproc visit, void *arg)
#else
    _PyArray_@name@(PyArrayObject *mp)
#endif
{
    npy_intp i, n;
    PyObject **data;
    /*
     * statically allocating it allows this function to not modify the
     * reference count of the array for use during dealloc.
     * (statically is not necessary as such)
     */
    PyArrayIterObject it;

    if (!PyDataType_REFCHK(PyArray_DESCR(mp))) {
        return 0;
    }
    printf("%d, %d\n", PyArray_DESCR(mp)->type_num, NPY_OBJECT);
    if (PyArray_DESCR(mp)->type_num != NPY_OBJECT) {
        PyArray_RawIterBaseInit(&it, mp);
        while (it.index < it.size) {
            CALL_INNER_FUNCTION(it.dataptr, PyArray_DESCR(mp));
            PyArray_ITER_NEXT(&it);
        }
        return 0;
    }

    if (PyArray_ISONESEGMENT(mp)) {
        data = (PyObject **)PyArray_DATA(mp);
        n = PyArray_SIZE(mp);
        if (PyArray_ISALIGNED(mp)) {
            for (i = 0; i < n; i++, data++) {
                HANDLE_ITEM_AT(data);
            }
        }
        else {
            for( i = 0; i < n; i++, data++) {
                HANDLE_ITEM_AT_UNALIGNED(data);
            }
        }
    }
    else { /* handles misaligned data too */
        PyArray_RawIterBaseInit(&it, mp);
        while (it.index < it.size) {
            data = (PyObject **)it.dataptr;
            HANDLE_ITEM_AT_UNALIGNED(data);
            PyArray_ITER_NEXT(&it);
        }
    }
    return 0;
}

#undef HANDLE_ITEM_AT
#undef HANDLE_ITEM_AT_UNALIGNED
#undef CALL_INNER_FUNCTION
#undef ERROR_RETURN

/**end repeat**/


/*NUMPY_API
 * XINCREF all objects in a single array item. This is complex for
 * structured datatypes where the position of objects needs to be extracted.
 * The function calls itself recursively for complex structured dtypes.
 */
NPY_NO_EXPORT void
PyArray_Item_INCREF(char *data, PyArray_Descr *descr)
{
    // Should return error value?
    _PyArray_Item_INCREF(data, descr);
    return;
}


/*NUMPY_API
 *
 * XDECREF all objects in a single array item. This is complex for
 * structured datatypes where the position of objects needs to be extracted.
 * The function calls itself recursively for complex structured dtypes.
 */
NPY_NO_EXPORT void
PyArray_Item_XDECREF(char *data, PyArray_Descr *descr)
{
    // Should return error value?
    _PyArray_Item_XDECREF(data, descr);
    return;
}


/* Used for arrays of python objects to increment the reference count of */
/* every python object in the array. */
/*NUMPY_API
  For object arrays, increment all internal references.
*/
NPY_NO_EXPORT int
PyArray_INCREF(PyArrayObject *mp)
{
    return _PyArray_INCREF(mp);
}


/*NUMPY_API
  Decrement all internal references for object arrays.
  (or arrays with object fields)
*/
NPY_NO_EXPORT int
PyArray_XDECREF(PyArrayObject *mp)
{
    return _PyArray_XDECREF(mp);
}


static void
_fillobject(char *optr, PyObject *obj, PyArray_Descr *dtype)
{
    if (!PyDataType_FLAGCHK(dtype, NPY_ITEM_REFCOUNT)) {
        if ((obj == Py_None) || (PyInt_Check(obj) && PyInt_AsLong(obj)==0)) {
            return;
        }
        else {
            PyObject *arr;
            Py_INCREF(dtype);
            arr = PyArray_NewFromDescr(&PyArray_Type, dtype,
                                       0, NULL, NULL, NULL,
                                       0, NULL);
            if (arr!=NULL) {
                dtype->f->setitem(obj, optr, arr);
            }
            Py_XDECREF(arr);
        }
    }
    if (dtype->type_num == NPY_OBJECT) {
        Py_XINCREF(obj);
        NPY_COPY_PYOBJECT_PTR(optr, &obj);
    }
    else if (PyDataType_HASFIELDS(dtype)) {
        PyObject *key, *value, *title = NULL;
        PyArray_Descr *new;
        int offset;
        Py_ssize_t pos = 0;

        while (PyDict_Next(dtype->fields, &pos, &key, &value)) {
            if NPY_TITLE_KEY(key, value) {
                continue;
            }
            if (!PyArg_ParseTuple(value, "Oi|O", &new, &offset, &title)) {
                return;
            }
            _fillobject(optr + offset, obj, new);
        }
    }
    else if (PyDataType_HASSUBARRAY(dtype)) {
        int size, i, inner_elsize;

        inner_elsize = dtype->subarray->base->elsize;
        if (inner_elsize == 0) {
            /* There cannot be any elements, so return */
            return;
        }
        /* Subarrays are always contiguous in memory */
        size = dtype->elsize / inner_elsize;

        /* Call _fillobject on each item recursively. */
        for (i = 0; i < size; i++){
            _fillobject(optr, obj, dtype->subarray->base);
            optr += inner_elsize;
        }
    }
    else {
        /* This path should not be reachable. */
        assert(0);
    }
    return;
}


/*NUMPY_API
 * Assumes contiguous
 */
NPY_NO_EXPORT void
PyArray_FillObjectArray(PyArrayObject *arr, PyObject *obj)
{
    npy_intp i,n;
    n = PyArray_SIZE(arr);
    if (PyArray_DESCR(arr)->type_num == NPY_OBJECT) {
        PyObject **optr;
        optr = (PyObject **)(PyArray_DATA(arr));
        n = PyArray_SIZE(arr);
        if (obj == NULL) {
            for (i = 0; i < n; i++) {
                *optr++ = NULL;
            }
        }
        else {
            for (i = 0; i < n; i++) {
                Py_INCREF(obj);
                *optr++ = obj;
            }
        }
    }
    else {
        char *optr;
        optr = PyArray_DATA(arr);
        for (i = 0; i < n; i++) {
            _fillobject(optr, obj, PyArray_DESCR(arr));
            optr += PyArray_DESCR(arr)->elsize;
        }
    }
}
